!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("ext-messenger",[],t):"object"==typeof exports?exports["ext-messenger"]=t():e["ext-messenger"]=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>y});const n="__messenger__",o="*",s="background",r="popup",i="devtool",a="content_script",c="init",d="init_success",g="message",l="response",u=["log","info","warn","error"],h="[ext-messenger]",_="[32m",m="[34m";function p(e){let t=Array.prototype.slice.call(arguments,1);var n;if(n=e,u.indexOf(n)>=u.indexOf("warn"))switch(e){case"log":console.log(_+h+` [${e}]`,...t);break;case"info":console.info(m+h+` [${e}]`,...t);break;case"warn":console.warn(h,...t);break;case"error":throw console.error(h,...t),"[ext-messenger] error occurred, check more information above...";default:console.error(h,`Unknown log level: ${e}`)}}const f={log:p,constructorTweakMethods:function(e,t){let n=function(n){let o=t[n];t[n]=function(){return p("log",`[${e}:${n}()]`,arguments),o.apply(t,arguments)}.bind(t)};for(let e in t)"function"==typeof t[e]&&n(e);Object.getOwnPropertyNames(Object.getPrototypeOf(t)).filter((e=>"function"==typeof t[e]&&"constructor"!==e)).forEach((e=>{t[e]=t[e].bind(t)}))},removeMessengerPortNamePrefix:function(e){return e.replace(new RegExp("^"+n),"")}},b=class{constructor(e={}){f.constructorTweakMethods("BackgroundHub",this),this._connectedHandler=e.connectedHandler,this._disconnectedHandler=e.disconnectedHandler,this._backgroundPorts={},this._contentScriptPorts={},this._popupPorts={},this._devtoolPorts={},chrome.runtime.onConnect.addListener(this._onPortConnected),self.mockPortOnConnect=this._onPortConnected}_onPortConnected(e){f.log("log","[BackgroundHub:runtime.onConnect]",arguments),0===e.name.indexOf(n)&&(e.onMessage.addListener(this._onPortMessageHandler),e.onDisconnect.addListener(this._onPortDisconnectionHandler))}_onPortMessageHandler(e,t){switch(e.type){case c:this._initConnection(e,t);break;case g:case l:e.to||f.log("error","[BackgroundHub:_onPortMessageHandler]",'Missing "to" in message:',e),e.toNames||f.log("error","[BackgroundHub:_onPortMessageHandler]",'Missing "toNames" in message:',e),this._relayMessage(e,t);break;default:f.log("error","[BackgroundHub:_onPortMessageHandler]","Unknown message type: "+e.type)}}_getPortsObj(e){switch(e){case s:return this._backgroundPorts;case a:return this._contentScriptPorts;case r:return this._popupPorts;case i:return this._devtoolPorts;default:f.log("error","[BackgroundHub:_onPortDisconnectionHandler]","Unknown extension part: "+e)}}_initConnection(e,t){let n=function(e,n){let o=this._getPortsObj(e);if(o[n]=o[n]?o[n]:[],o[n].push(t),this._connectedHandler){let o=e!==s?n:null,r=f.removeMessengerPortNamePrefix(t.name);this._connectedHandler(e,r,o)}t.postMessage({from:s,type:d})}.bind(this);if(e.from===s)n(s,1);else if(e.from===i)n(i,e.tabId);else if(e.from===a)n(a,t.sender.tab.id);else{if(e.from!==r)throw new Error('Unknown "from" in message: '+e.from);n(r,e.tabId)}}_relayMessage(e,t){let n,c,d=e.from,g=e.to,l=e.toNames,u=e.toTabId;d===s?g!==s&&(n=u):d===i||d===r?n=e.tabId:d===a?n=t.sender.tab.id:f.log("error","[BackgroundHub:_relayMessage]",'Unknown "from" in message: '+d),e.fromTabId=n,g===s?c=this._backgroundPorts[1]?this._backgroundPorts[1]:[]:g===i?c=this._devtoolPorts[n]?this._devtoolPorts[n]:[]:g===r?c=this._popupPorts[n]?this._popupPorts[n]:[]:g===a?c=this._contentScriptPorts[n]?this._contentScriptPorts[n]:[]:f.log("error","[BackgroundHub:_relayMessage]",'Unknown "to" in message: '+g),0===c.length&&f.log("info","[BackgroundHub:_relayMessage]",'Not sending relay because "to" port does not exist');let h=[];l.forEach(function(e){let t=c.filter((function(t){return t.name===e||e===o}));t.length>0?t.forEach((function(e){-1===h.indexOf(e)&&h.push(e)})):f.log("warn","[BackgroundHub:_relayMessage]","Could not find any connections with this name (probably no such name):",g,f.removeMessengerPortNamePrefix(e))}.bind(this)),e.fromPortSender=t.sender,h.forEach(function(t){t.postMessage(e)}.bind(this))}_onPortDisconnectionHandler(e){e.onMessage.removeListener(this._onPortMessageHandler);let t=function(e,t){let n=this._getPortsObj(e),o=Object.keys(n);for(let r=0;r<o.length;r++){let i=o[r],a=n[i];for(let n=a.length;n>=0;n--)if(a[n]===t&&(f.log("log","[BackgroundHub:_onPortDisconnectionHandler]","Remove connection of port with unique id: ",i),a.splice(n,1),this._disconnectedHandler)){let n=e!==s?parseInt(i):null,o=f.removeMessengerPortNamePrefix(t.name);this._disconnectedHandler(e,o,n)}0===n[i].length&&(f.log("log","[BackgroundHub:_onPortDisconnectionHandler]","Removing empty ports object for unique id: ",i),delete n[i])}}.bind(this);t(s,e),t(a,e),t(r,e),t(i,e)}},P=class{constructor(e){f.constructorTweakMethods("MockPort",this);let t=this._createMockPort(e),n=this._createMockPort(e);return this._linkMocks(t,n),self&&"function"==typeof self.mockPortOnConnect&&self.mockPortOnConnect(n),t}_createMockPort(e){let t={_connected:!0,_name:e.name,onMessageListeners:[],onDisconnectListeners:[]};return Object.defineProperty(t,"name",{get:function(){return t._name}}),Object.defineProperty(t,"onMessage",{get:function(){return{addListener:function(e){t.onMessageListeners.push(e)},removeListener:function(e){let n=t.onMessageListeners.indexOf(e);-1!==n&&t.onMessageListeners.splice(n,1)}}}}),Object.defineProperty(t,"onDisconnect",{get:function(){return{addListener:function(e){t.onDisconnectListeners.push(e)},removeListener:function(e){let n=t.onDisconnectListeners.indexOf(e);-1!==n&&t.onDisconnectListeners.splice(n,1)}}}}),Object.defineProperty(t,"sender",{get:function(){return{id:chrome.runtime.id}}}),t.postMessage=function(e){t._connected?t.__targetRefPort?t.__targetRefPort.__invokeOnMessageHandlers(e):f.log("warn","[MockPort:postMessage]","Missing __targetRefPort",arguments):f.log("warn","[MockPort:postMessage]","Attempting to post message on a disconnected mock port",e)},t.disconnect=function(){t._connected=!1,t.__targetRefPort?t.__targetRefPort.__invokeOnDisconnectHandlers():f.log("warn","[MockPort:postMessage]","Missing __targetRefPort",arguments),t._onMessageListeners=[],t._onDisconnectListeners=[]},t.__invokeOnMessageHandlers=function(e){t.onMessageListeners.forEach((function(n){n(e,t)}))},t.__invokeOnDisconnectHandlers=function(){t.onDisconnectListeners.forEach((function(e){e(t)}))},t}_linkMocks(e,t){e.__targetRefPort=t,t.__targetRefPort=e}},M=class{constructor(e,t,n){return f.constructorTweakMethods("Connection",this),this.extPart=e,this.name=t,this._init(this.extPart,this.name,n),{extPart:this.extPart,name:this.name,sendMessage:this.sendMessage,disconnect:this.disconnect}}_init(e,t,o){switch(this._port=null,this._inited=!1,this._pendingInitMessages=[],this._pendingCb={},this._cbId=0,this._pendingCbCleanupIndex=0,this._myExtPart=e,this._myName=n+t,this._userMessageHandler=o||function(){},this._myExtPart){case s:case a:case r:case i:{let e=function(t){f.log("log","[Connection:_init]","Attempting connection initing..."),this._port=this._myExtPart===s?new P({name:this._myName}):chrome.runtime.connect({name:this._myName}),this._port.onMessage.addListener(this._onPortMessageHandler),this._port.postMessage({type:c,from:this._myExtPart,tabId:t});let n=arguments,o=setTimeout(function(){this._inited?clearTimeout(o):(this._port.disconnect(),e.apply(this,n))}.bind(this),500)}.bind(this);switch(this._myExtPart){case s:case a:e();break;case r:chrome.tabs.query({active:!0,currentWindow:!0},(function(t){e(t[0].id)}));break;case i:e(chrome.devtools.inspectedWindow.tabId)}break}default:f.log("error","[Connection:_init]","Unknown extension part: "+e)}}_attemptDeadCbCleanup(){if(Object.keys(this._pendingCb).length>1e5){f.log("log","[Connection:_attemptDeadCbCleanup]","Attempting dead callback cleaning... current callbacks number:".Object.keys(this._pendingCb).length);let e=this._pendingCbCleanupIndex+5e3;for(;this._pendingCbCleanupIndex<e;)delete this._pendingCb[this._pendingCbCleanupIndex],this._pendingCbCleanupIndex++;f.log("log","[Connection:_attemptDeadCbCleanup]","New callbacks number after cleaning done:",Object.keys(this._pendingCb).length)}}_prepareMessage(e,t){return new Promise((n=>{switch(t&&(this._cbId++,this._pendingCb[this._cbId]=t,e.cbId=this._cbId,this._attemptDeadCbCleanup()),this._myExtPart){case i:e.tabId=chrome.devtools.inspectedWindow.tabId,n();break;case r:chrome.tabs.query({active:!0,currentWindow:!0},function(t){e.tabId=t[0].id,n()}.bind(this));break;default:n()}}))}_postMessage(e,t,n){this._prepareMessage(t,n).then((()=>{this._inited?e.postMessage(t):this._pendingInitMessages.push(t)}))}_postResponse(e,t,n){let o={from:this._myExtPart,to:n.from,toNames:[n.fromName],type:l,cbId:n.cbId,cbValue:t};this._myExtPart===s&&(o.toTabId=n.fromTabId),this._postMessage(e,o)}_handleMessage(e,t){let n=function(n){e.cbId&&this._postResponse(t,n,e)}.bind(this),o=f.removeMessengerPortNamePrefix(e.fromName),r=e.fromTabId&&e.from!==s?`:${e.fromTabId}`:null,i=`${e.from}:${o}`+(r?`:${r}`:"");this._userMessageHandler(e.userMessage,i,e.fromPortSender,n)}_handleResponse(e){if(this._pendingCb[e.cbId]){let t=this._pendingCb[e.cbId];delete this._pendingCb[e.cbId],t(e.cbValue)}else f.log("info","[Connection:_handleResponse]","Ignoring response sending because callback does not exist (probably already been called)")}_sendMessage(e,t,n,o,s,r){n=this._addMessengerPortNamePrefix(n);let i={from:this._myExtPart,fromName:this._myName,to:t,toNames:n,toTabId:o,type:g,userMessage:s};this._postMessage(e,i,r)}_addMessengerPortNamePrefix(e){return e.map((function(e){return e===o?e:n+e}))}_validateMessage(e,t,n){if(!e)return'Missing extension part in "to" argument';if(e!==s&&e!==a&&e!==i&&e!==r)return'Unknown extension part in "to" argument: '+e+"\nSupported parts are: "+s+", "+a+", "+r+", "+i;if(!t)return'Missing connection name in "to" argument';if(this._myExtPart===s&&e!==s){if(!n)return'Messages from background to other extension parts must have a tab id in "to" argument';if(!Number.isInteger(parseFloat(n)))return"Tab id to send message to must be a valid number"}}_onPortMessageHandler(e,t){switch(e.type){case d:this._inited=!0,this._pendingInitMessages.forEach(function(e){this._port.postMessage(e)}.bind(this));break;case g:case l:e.to||f.log("error","[Connection:_onPortMessageHandler]",'Missing "to" in message: ',e),e.toNames||f.log("error","[Connection:_onPortMessageHandler]",'Missing "toNames" in message: ',e),e.type===g?this._handleMessage(e,t):e.type===l&&this._handleResponse(e);break;default:f.log("error","[Connection:_onPortMessageHandler]","Unknown message type: "+e.type)}}sendMessage(e,t){return new Promise(((n,o)=>{if(e||f.log("error","[Connection:sendMessage]",'Missing "to" arguments'),!this._port)return f.log("info","[Connection:sendMessage]","Rejecting sendMessage because connection does not exist anymore"),o(new Error("Connection port does not exist anymore, did you disconnect it?"));let s;try{s=e.split(":")}catch(t){f.log("error","[Connection:sendMessage]",'Invalid format given in "to" argument: '+e,arguments)}let r=s[0],i=s[1],a=s[2],c=this._validateMessage(r,i,a);c&&f.log("error","[Connection:sendMessage]",c,arguments);let d=i.split(",");this._sendMessage(this._port,r,d,a,t,n)}))}disconnect(){this._port&&(this._port.disconnect(),this._port=null)}};class k{constructor(e){if(f.constructorTweakMethods("Messenger",this),!Object.values(k.EXT_PARTS).includes(e))return void f.log("error","[Messenger:constructor]",`"${e}" provided is not a valid extension part. Valid parts are: ${Object.keys(k.EXT_PARTS).join(", ")}`);this._myExtPart=e;let t={initConnection:this.initConnection};return this._myExtPart===s&&(t.initBackgroundHub=this.initBackgroundHub),t}static isMessengerPort(e){return 0===e.name.indexOf(n)}static EXT_PARTS={BACKGROUND:s,POPUP:r,DEVTOOL:i,CONTENT_SCRIPT:a};initBackgroundHub(e){this._myExtPart===s?this._backgroundHub?f.log("warn","[Messenger:initBackgroundHub]","Ignoring BackgroundHub init request since it is already been inited"):this._backgroundHub=new b(e):f.log("warn","[Messenger:initBackgroundHub]","Ignoring BackgroundHub init request since not called from background context")}initConnection(e,t){return e||f.log("error","[Messenger:initConnection]",'Missing "name" in arguments'),e===o&&f.log("error","[Messenger:initConnection]",'"*" is reserved as a wildcard identifier, please use another name'),new M(this._myExtPart,e,t)}}const y=k;return t})()));
//# sourceMappingURL=ext-messenger.min.js.map